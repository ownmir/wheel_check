!!! Prev file: vyperInterfaces  !!!

	Event Logging Журнал событий

Vyper can log events to be caught and displayed by user interfaces.
Vyper может регистрировать события, которые будут обнаружены и отображены пользовательскими интерфейсами.

	Example of Logging Пример ведения журнала
This example is taken from the sample ERC20 contract and shows the basic flow of event logging:
Этот пример взят из образца контракта ERC20 и показывает основной поток регистрации событий:
	code:
# Events of the token. События токена.
event Transfer:  # Перевод
    sender: indexed(address)
    receiver: indexed(address)
    value: uint256

event Approval:  # Утверждение одобрение
    owner: indexed(address)
    spender: indexed(address)  #  Тот, кто тратит
    value: uint256

# Transfer some tokens from message sender to another address Перевести некоторые токены от отправителя сообщения на другой адрес
def transfer(_to : address, _value : uint256) -> bool:

   ... Logic here to do the real work Здесь логика, чтобы делать настоящую работу ...

   # All done, log the event for listeners Готово, запишите событие для слушателей
   log Transfer(msg.sender, _to, _value)

=============================================================

Let’s look at what this is doing.
1. We declare two event types to log. The two events are similar in that they contain 
two indexed address fields. 
Indexed fields do not make up part of the event data itself, but can be searched by clients that want to catch the event. 
Also, each event contains one single data field, in each case called value. 
Events can contain several arguments with any names desired.
2. In the transfer function, after we do whatever work is necessary, we log the event. 
We pass three arguments, corresponding with the three arguments of the Transfer event declaration.

Давайте посмотрим на то, что это делает.
1. Мы объявляем для регистрации два типа событий. Эти два события похожи тем, что содержат 
два индексированных адресных поля. 
Индексированные поля не составляют часть самих данных о событии, но могут быть найдены клиентами, которые хотят поймать событие. 
Кроме того, каждое событие содержит одно поле данных, в каждом случае называемое значением. 
События могут содержать несколько аргументов с любыми желаемыми именами.
2. В функции transfer после того, как мы сделаем все необходимое, мы регистрируем событие. 
Мы передаем три аргумента, соответствующие трем аргументам объявления события Transfer.

Clients listening to the events will declare and handle the events they are interested in using a library such as web3.js:
Клиенты, слушающие события, будут объявлять и обрабатывать события, которые им интересны, используя такую библиотеку, как web3.js:

	code:
var abi = /* abi as generated by the compiler */;
var MyToken = web3.eth.contract(abi);
var myToken = MyToken.at("0x1234...ab67" /* address */);

// watch for changes in the callback
var event = myToken.Transfer(function(error, result) {
    if (!error) {
        var args = result.returnValues;
        console.log('value transferred = ', args._amount);
    }
});

In this example, the listening client declares the event to listen for. 
Any time the contract sends this log event, the callback will be invoked.

В этом примере слушающий клиент объявляет событие, которое нужно слушать. 
Каждый раз, когда контракт отправляет это событие журнала, вызывается обратный вызов.

	Declaring Events Объявление событий

Let’s look at an event declaration in more detail.
Рассмотрим объявление события более подробно.

Event declarations look similar to struct declarations, containing one or more arguments that are passed to the event. 
Typical events will contain two kinds of arguments:

-Indexed arguments, which can be searched for by listeners. Each indexed argument is identified by the indexed keyword. 
Here, each indexed argument is an address. You can have any number of indexed arguments, 
but indexed arguments are not passed directly to listeners, 
although some of this information (such as the sender) may be available in the listener’s results object.

-Value arguments, which are passed through to listeners. You can have any number of value arguments 
and they can have arbitrary names, but each is limited by the EVM to be no more than 32 bytes.

It is also possible to create an event with no arguments. In this case, use the pass statement:

Объявления событий похожи на объявления структур, содержащие один или несколько аргументов, которые передаются событию. 
Типичные события будут содержать два типа аргументов:
-Индексированные аргументы, которые могут искать слушатели. Каждый проиндексированный аргумент идентифицируется индексированным ключевым словом. 
Здесь каждый индексированный аргумент - это адрес. У вас может быть любое количество индексированных аргументов, 
но индексированные аргументы не передаются непосредственно слушателям, 
хотя некоторая часть этой информации (например, отправитель) 
может быть доступна в объекте результатов слушателя.
-Аргументы значения, которые передаются слушателям. У вас может быть любое количество аргументов-значений, 
и они могут иметь произвольные имена, но каждый из них ограничен EVM, чтобы он не превышал 32 байта.

Также возможно создать событие без аргументов. В этом случае используйте инструкцию pass:

event Foo: pass



!!! Next file: vyperNatSpecMetadata  !!!