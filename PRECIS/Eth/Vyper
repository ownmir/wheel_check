https://kauri.io/an-introduction-to-smart-contracts-with-vyper/af913a853eaf4db88627b3ff9572b770/a
	An Introduction to Smart Contracts with Vyper
	Введение в смарт-контракты с Vyper

Vyper is a smart contract-oriented, pythonic programming language that targets the Ethereum Virtual Machine (EVM).
It aims to follow the similar simplicity, security and readability principles of Python and provides the following features:
Vyper - это питонический язык программирования, ориентированный на смарт-контракты и ориентированный на виртуальную машину Ethereum (EVM).
Он направлен на соблюдение тех же принципов простоты, безопасности и удобочитаемости, что и Python, и предоставляет следующие функции:
- Bounds and overflow checking: On array accesses as well as on arithmetic level.
Проверка границ и переполнения: при доступе к массиву, а также на арифметическом уровне.
- Support for signed integers and decimal fixed point numbers
Поддержка целых чисел со знаком и десятичных чисел с фиксированной запятой
- Decidability: It should be possible to compute a precise upper bound for the gas consumption of any function call.
Разрешимость: должна быть возможность вычислить точную верхнюю границу потребления газа для любого вызова функции.
- Strong typing: Including support for units (e.g., timestamp, timedelta, seconds, wei, wei per second, meters per second squared).
Строгая типизация: включая поддержку единиц (например, метка времени, период времени, секунды, wei, wei в секунду, метры в секунду 
в квадрате).
- Small and understandable compiler code
Короткий и понятный код компилятора
- Limited support for pure functions: Anything marked constant is not allowed to change the state.
Ограниченная поддержка чистых функций: все, что помечено как константа, не может изменять состояние.

And to follow similar principles, Vyper does not support:
И чтобы следовать аналогичным принципам, Vyper не поддерживает:
- Modifiers Модификаторы
- Class inheritance       Наследование классов
- Inline assembly         Встроенная сборка            
- Function overloading    Перегрузка функций           
- Operator overloading    Перегрузка оператора         
- Recursive calling       Рекурсивный вызов            
- Infinite-length loops   Циклы бесконечной длины      
- Binary fixed point      Бинарная фиксированная точка 

        Introductory Open Auction Example
	Вводный пример открытого аукциона

As an introductory example of a smart contract written in Vyper, we begin with an open auction contract.
В качестве вводного примера смарт-контракта, написанного на Vyper, мы начнем с контракта на открытом аукционе.
All Vyper syntax is valid Python3 syntax, however not all Python3 functionality is available in Vyper.
Весь синтаксис Vyper является допустимым синтаксисом Python3, однако не все функции Python3 доступны в Vyper.
In this contract, participants can submit bids during a limited time period. When the auction period 
ends, a predetermined beneficiary receives the amount of the highest bid.
В этом контракте участники могут подавать заявки в течение ограниченного периода времени. Когда период аукциона 
заканчивается, заранее определенный бенефициар получает сумму наивысшей ставки.
	code:
# Open Auction                                       Открытый аукцион                                                         
                                                                                                                              
# Auction params                                     Параметры аукциона                                                       
# Beneficiary receives money from the highest bidder Получатель получает деньги от участника, предложившего 
# самую высокую цену
beneficiary: public(address)
auctionStart: public(timestamp)
auctionEnd: public(timestamp)

# Current state of auction # Текущее состояние аукциона
highestBidder: public(address)
highestBid: public(wei_value)

# Set to true at the end, disallows any change # Установка значения true в конце, запрещает любые изменения
ended: public(bool)

# Keep track of refunded bids so we can follow the withdraw pattern
# Следите за возвращенными ставками, чтобы мы могли следовать схеме вывода
pendingReturns: public(map(address, wei_value))

# Create a simple auction with `_bidding_time` Создайте простой аукцион с `_bidding_time`
# seconds bidding time on behalf of the        секунды времени ставки от имени           
# beneficiary address `_beneficiary`.          адрес получателя `_beneficiary`.          
@public
def __init__(_beneficiary: address, _bidding_time: timedelta):
    self.beneficiary = _beneficiary
    self.auctionStart = block.timestamp
    self.auctionEnd = self.auctionStart + _bidding_time

# Bid on the auction with the value sent Ставка на аукцион с отправленной стоимостью
# together with this transaction.        вместе с этой транзакцией.                 
# The value will only be refunded if the Стоимость будет возвращена, только если    
# auction is not won.                    аукцион не выигран.                        
@public
@payable
def bid():
    # Check if bidding period is over. Проверить, закончился ли период торгов.
    assert block.timestamp < self.auctionEnd
    # Check if bid is high enough Проверить, достаточно ли высока ставка
    assert msg.value > self.highestBid
    # Track the refund for the previous high bidder Отследить возврат средств за предыдущую ставку
    self.pendingReturns[self.highestBidder] += self.highestBid
    # Track new high bid Отследить новую высокую ставку
    self.highestBidder = msg.sender
    self.highestBid = msg.value
